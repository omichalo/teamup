# API Security

## Sécurité des routes API

### Runtime Node.js

- **TOUJOURS** spécifier `export const runtime = "nodejs";` en haut des routes API qui utilisent :
  - Des modules Node.js natifs (fs, path, crypto, etc.)
  - Firebase Admin SDK
  - Des bibliothèques nécessitant le runtime Node.js (tweetnacl, etc.)

### Protection CSRF

- **TOUJOURS** utiliser `validateOrigin(req)` sur les mutations (POST, PATCH, DELETE, PUT)
- Importer depuis `@/lib/auth/csrf-utils`
- Retourner 403 si l'origine est invalide
- Exemple :
  ```typescript
  if (!validateOrigin(req)) {
    return NextResponse.json({ error: "Invalid origin" }, { status: 403 });
  }
  ```

### Rate Limiting

- Appliquer le rate limiting sur les routes sensibles :
  - Envoi d'emails (password reset, verification)
  - Authentification (login, signup)
  - Toute route exposée à des attaques de brute-force
- Utiliser `checkRateLimit()` depuis `@/lib/auth/rate-limit`
- Retourner 429 avec un message informatif si la limite est dépassée
- Exemple :
  ```typescript
  const rateLimitResult = checkRateLimit(`email:${email}`, 3, 15 * 60 * 1000);
  if (!rateLimitResult.allowed) {
    return NextResponse.json({ error: "Trop de requêtes" }, { status: 429 });
  }
  ```

### Headers de sécurité (Cache-Control)

- **TOUJOURS** ajouter `Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate` sur les réponses sensibles :
  - Routes de session (`/api/session/*`)
  - Routes d'authentification (`/api/auth/*`)
  - Routes admin (`/api/admin/*`)
  - Toute route contenant des données utilisateur ou sensibles
- Ajouter également `Pragma: no-cache` et `Expires: 0` pour compatibilité
- Exemple :
  ```typescript
  const res = NextResponse.json(data);
  res.headers.set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate");
  res.headers.set("Pragma", "no-cache");
  res.headers.set("Expires", "0");
  return res;
  ```

### Cookies sécurisés

- **TOUJOURS** configurer les cookies de session avec :
  - `httpOnly: true` (protection XSS)
  - `secure: true` en production (HTTPS uniquement)
  - `sameSite: "strict"` en production, `"lax"` en développement
  - Configuration homogène entre création et suppression
- Exemple :
  ```typescript
  const isProduction = process.env.NODE_ENV === "production";
  res.cookies.set({
    name: "__session",
    value: sessionCookie,
    httpOnly: true,
    secure: isProduction,
    sameSite: isProduction ? "strict" : "lax",
    path: "/",
    maxAge: 14 * 24 * 60 * 60, // 14 jours
  });
  ```

### Audit Logging

- Logger toutes les actions critiques avec `logAuditAction()` depuis `@/lib/auth/audit-logger`
- Actions à logger :
  - Modification de rôles utilisateur
  - Approbation/rejet de demandes coach
  - Synchronisation de données (joueurs, équipes, matchs)
  - Import/export de données
  - Suppression de ressources
- **TOUJOURS** masquer les données sensibles (emails, tokens, secrets) dans les logs
- Utiliser les constantes `AUDIT_ACTIONS` pour la cohérence
- Exemple :
  ```typescript
  logAuditAction(AUDIT_ACTIONS.USER_ROLE_CHANGED, decoded.uid, {
    resource: "user",
    resourceId: userId,
    details: { oldRole, newRole },
    success: true,
  });
  ```

### Logs conditionnels

- **NE JAMAIS** logger de données sensibles en production :
  - Chemins de fichiers de service account
  - Clés privées ou tokens
  - Liens de réinitialisation de mot de passe
  - Variables d'environnement complètes
- Utiliser des logs conditionnels : `if (process.env.NODE_ENV === "development" && process.env.DEBUG === "true")`
- Masquer les valeurs sensibles même en debug (ex: `"***"` ou `value.substring(0, 10) + "***"`)
- Exemple :
  ```typescript
  if (process.env.NODE_ENV === "development" && process.env.DEBUG === "true") {
    console.log("[debug] Info non sensible:", { key: "value" });
  }
  ```

## API, Erreurs & Validation

- Pour chaque appel API (server ou client), gérer explicitement les erreurs (try/catch, check des status HTTP).
- Pour les entrées utilisateur (formulaires, query params, body JSON), valider les données (Zod ou logique de validation explicite).
- Toujours renvoyer des réponses HTTP cohérentes : 200, 400, 401, 403, 404, 429, 500, avec un message d'erreur utile.
- Ne pas exposer l'error stack complète dans la réponse JSON, seulement un message générique + éventuellement details (message d'erreur simple).
- **Gestion d'erreurs différenciée** : Utiliser les codes HTTP appropriés selon le type d'erreur :
  - 400 : Données invalides (format email, paramètres manquants)
  - 401 : Non authentifié (session manquante/invalide)
  - 403 : Accès refusé (rôle insuffisant)
  - 404 : Ressource non trouvée
  - 429 : Trop de requêtes (rate limiting)
  - 500 : Erreur serveur interne
- **Validation d'entrée** : Toujours valider le format des données avant traitement (ex: regex pour emails, validation de types)
- **Messages d'erreur utilisateur** : Fournir des messages clairs et utiles sans exposer de détails techniques ou de stack traces
