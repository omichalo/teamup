# Règles de développement Next.js

## Configuration et outils

Pendant le développement (quand npm run dev est actif), utilise npm run check:dev (lint + type-check sans build) pour éviter les conflits avec le serveur de développement.
Avant chaque commit sur le projet Next.js, exécute npm run check (lint + type-check + build) et corrige toutes les erreurs de build, de lint et de typage avant de t'arrêter.
Après un npm run check, un npm run build ou un push git, relancer proprement le serveur de dev (arrêter puis redémarrer).
Ne jamais faire de --no-verify sur les commandes git
Toujours refuser de pousser sur git un code avec des TODO
Une fois le code poussé sur github, toujours s'assurer que le serveur de dev est lancé sur le port 3000. Le relancer si besoin.

## Principes généraux

Tu appliques systématiquement les principes de développement DRY et SOLID.

### Qualité production

- Toujours respecter l'architecture existante du projet (structure des dossiers, conventions de nommage, style de code).
- Utiliser TypeScript de manière stricte : pas de 'any' implicite, pas de 'as any' sauf cas ultra-justifié.
- Préserver les définitions de types existantes (types, interfaces, schemas Zod, etc.) et les améliorer plutôt que les casser.
- Ne jamais introduire de code mort, d'imports inutilisés, de console.log permanents ou de TODO laissés sans contexte.
- Toujours garder le code lisible, modulaire et cohérent : fonctions courtes, composants simples, pas de duplication.

## Next.js / App Router

- Utiliser l'App Router (dossier 'app/') et respecter la séparation Server Components / Client Components.
- Par défaut, créer des Server Components. N'ajouter 'use client' que si c'est nécessaire (state, effets, événements, hooks client).
- Pour les routes API, utiliser les route handlers dans 'app/\*\*/route.ts' avec les bonnes signatures Request/Response.
- Respecter les conventions Next : 'page.tsx', 'layout.tsx', 'loading.tsx', 'error.tsx', 'not-found.tsx' quand cela a du sens.
- Utiliser le cache Next/fetch de façon explicite (cache, revalidate) et éviter les appels inutiles côté client.
- Forcer le runtime Node.js pour les routes API nécessitant des modules Node.js : `export const runtime = "nodejs";`

## React / Composants

- Écrire des composants fonctionnels simples, bien typés : props claires, pas de logique métier massive dans le JSX.
- Extraire la logique métier dans des fonctions/utilitaires ou hooks dédiés (ex: 'useXxx', fonctions dans 'lib/').
- Respecter le principe 'single responsibility' : un composant ne fait qu'une chose (affichage / logique locale).
- Utiliser les fragments, éviter les wrappers inutiles.
- Utiliser React.memo, useMemo, useCallback seulement quand il y a un vrai bénéfice (liste lourde, prop stable...).

## TypeScript

- Toujours produire du code en TypeScript (pas en JavaScript).
- Utiliser `strict` TypeScript (pas d'`any` implicite).
- Toujours typer les props des composants, les retours de fonctions et les paramètres importants.
- Préférer des types précis (discriminated unions, enums, Record, etc.) plutôt que 'string'/'any' vagues.
- Garder les types réutilisables dans un endroit cohérent (ex: 'types/', 'lib/types.ts').
- Respecter l'ESLint/Prettier configuré dans le projet.
- Interdire la génération de code avec erreurs de compilation.

## API, Erreurs & Validation

- Pour chaque appel API (server ou client), gérer explicitement les erreurs (try/catch, check des status HTTP).
- Pour les entrées utilisateur (formulaires, query params, body JSON), valider les données (Zod ou logique de validation explicite).
- Toujours renvoyer des réponses HTTP cohérentes : 200, 400, 401, 403, 404, 429, 500, avec un message d'erreur utile.
- Ne pas exposer l'error stack complète dans la réponse JSON, seulement un message générique + éventuellement details (message d'erreur simple).
- **Gestion d'erreurs différenciée** : Utiliser les codes HTTP appropriés selon le type d'erreur :
  - 400 : Données invalides (format email, paramètres manquants)
  - 401 : Non authentifié (session manquante/invalide)
  - 403 : Accès refusé (rôle insuffisant)
  - 404 : Ressource non trouvée
  - 429 : Trop de requêtes (rate limiting)
  - 500 : Erreur serveur interne
- **Validation d'entrée** : **TOUJOURS** utiliser les helpers de validation depuis `@/lib/api/validation-helpers` :
  - `validateEmail(email, fieldName?)` - Valide un email (présence + format)
  - `validateId(id, fieldName)` - Valide un ID (format alphanumérique, tirets, underscores)
  - `validateRequired(value, fieldName)` - Valide qu'une valeur est présente
  - `validateRequiredFields(fields)` - Valide plusieurs champs en une fois
  - `validatePositiveInteger(value, fieldName)` - Valide un entier positif
- **NE JAMAIS** valider manuellement les emails avec des regex (utiliser `validateEmail`)
- **NE JAMAIS** valider manuellement les IDs (utiliser `validateId`)
- Exemple :
  ```typescript
  const emailError = validateEmail(email);
  if (emailError) return emailError;
  
  const idError = validateId(teamId, "teamId");
  if (idError) return idError;
  ```
- **Messages d'erreur utilisateur** : Fournir des messages clairs et utiles sans exposer de détails techniques ou de stack traces

## Firestore

- Quand une collection est manipulée, tu t'assures systématiquement que les bonnes règles sont positionnées. Tu n'ouvres que le strict minimum pour que cela fonctionne

## Sécurité des routes API

### Runtime Node.js

- **TOUJOURS** spécifier `export const runtime = "nodejs";` en haut des routes API qui utilisent :
  - Des modules Node.js natifs (fs, path, crypto, etc.)
  - Firebase Admin SDK
  - Des bibliothèques nécessitant le runtime Node.js (tweetnacl, etc.)

### Middlewares d'authentification

- **TOUJOURS** utiliser les middlewares d'authentification depuis `@/lib/api/auth-middleware` :
  - `requireAuth(req, options?)` - Authentification de base avec support des rôles
  - `requireAdmin(req)` - Wrapper pour ADMIN uniquement
  - `requireAdminOrCoach(req, requireEmailVerified?)` - Wrapper pour ADMIN ou COACH
  - `requireAdminWithEmailVerified(req)` - Wrapper pour ADMIN avec email vérifié obligatoire
- Options disponibles pour `requireAuth` :
  - `allowedRoles?: UserRole[]` - Rôles autorisés
  - `requireEmailVerified?: boolean` - Exiger un email vérifié (défaut: false)
  - `validateCSRF?: boolean` - Valider l'origine (défaut: true pour mutations)
- **NE JAMAIS** utiliser `adminAuth.verifySessionCookie()` directement dans les routes API (sauf routes spéciales comme `/api/session`)
- Exemple :
  ```typescript
  const auth = await requireAdminOrCoach(req, true); // requireEmailVerified = true
  if (auth instanceof Response) return auth;
  // auth.decoded, auth.role, auth.uid sont disponibles
  ```

### Protection CSRF

- **TOUJOURS** utiliser `validateOrigin(req)` sur les mutations (POST, PATCH, DELETE, PUT)
- **Note** : Les middlewares `requireAuth` valident automatiquement CSRF pour les mutations
- Pour les routes publiques, utiliser `validateOrigin(req)` manuellement
- Importer depuis `@/lib/auth/csrf-utils`
- Retourner 403 si l'origine est invalide
- Exemple :
  ```typescript
  if (!validateOrigin(req)) {
    return NextResponse.json({ error: "Invalid origin" }, { status: 403 });
  }
  ```

### Rate Limiting

- Appliquer le rate limiting sur les routes sensibles :
  - Envoi d'emails (password reset, verification)
  - Authentification (login, signup)
  - Toute route exposée à des attaques de brute-force
- **TOUJOURS** utiliser le middleware `withRateLimit()` depuis `@/lib/api/rate-limit-middleware`
- Retourne automatiquement 429 avec un message informatif si la limite est dépassée
- Exemple :
  ```typescript
  const rateLimitError = withRateLimit({
    key: `email:${email}`,
    maxRequests: 3,
    windowMs: 15 * 60 * 1000,
    errorMessage: "Veuillez patienter avant de renvoyer un email.",
  });
  if (rateLimitError) return rateLimitError;
  ```

### Headers de sécurité (Cache-Control)

- **TOUJOURS** utiliser `createSecureResponse()` depuis `@/lib/api/response-utils` pour les réponses sensibles
- Cette fonction ajoute automatiquement les headers de sécurité :
  - `Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate`
  - `Pragma: no-cache`
  - `Expires: 0`
- Routes concernées :
  - Routes de session (`/api/session/*`)
  - Routes d'authentification (`/api/auth/*`)
  - Routes admin (`/api/admin/*`)
  - Toute route contenant des données utilisateur ou sensibles
- **NE JAMAIS** utiliser `NextResponse.json()` directement pour les réponses sensibles
- Exemple :
  ```typescript
  return createSecureResponse(data, 200);
  // Au lieu de :
  // const res = NextResponse.json(data);
  // res.headers.set("Cache-Control", "...");
  // return res;
  ```

### Cookies sécurisés

- **TOUJOURS** configurer les cookies de session avec :
  - `httpOnly: true` (protection XSS)
  - `secure: true` en production (HTTPS uniquement)
  - `sameSite: "strict"` en production, `"lax"` en développement
  - Configuration homogène entre création et suppression
- Exemple :
  ```typescript
  const isProduction = process.env.NODE_ENV === "production";
  res.cookies.set({
    name: "__session",
    value: sessionCookie,
    httpOnly: true,
    secure: isProduction,
    sameSite: isProduction ? "strict" : "lax",
    path: "/",
    maxAge: 14 * 24 * 60 * 60, // 14 jours
  });
  ```

### Audit Logging

- Logger toutes les actions critiques avec `logAuditAction()` depuis `@/lib/auth/audit-logger`
- Actions à logger :
  - Modification de rôles utilisateur
  - Approbation/rejet de demandes coach
  - Synchronisation de données (joueurs, équipes, matchs)
  - Import/export de données
  - Suppression de ressources
- **TOUJOURS** masquer les données sensibles (emails, tokens, secrets) dans les logs
- Utiliser les constantes `AUDIT_ACTIONS` pour la cohérence
- Exemple :
  ```typescript
  logAuditAction(AUDIT_ACTIONS.USER_ROLE_CHANGED, decoded.uid, {
    resource: "user",
    resourceId: userId,
    details: { oldRole, newRole },
    success: true,
  });
  ```

### Logs conditionnels

- **NE JAMAIS** logger de données sensibles en production :
  - Chemins de fichiers de service account
  - Clés privées ou tokens
  - Liens de réinitialisation de mot de passe
  - Variables d'environnement complètes
- Utiliser des logs conditionnels : `if (process.env.NODE_ENV === "development" && process.env.DEBUG === "true")`
- Masquer les valeurs sensibles même en debug (ex: `"***"` ou `value.substring(0, 10) + "***"`)
- Exemple :
  ```typescript
  if (process.env.NODE_ENV === "development" && process.env.DEBUG === "true") {
    console.log("[debug] Info non sensible:", { key: "value" });
  }
  ```

## Sécurité et contrôle d'accès - Cohérence Client/Serveur

### Règle fondamentale : Vérifications de rôles cohérentes

**TOUJOURS vérifier les rôles à la fois côté client ET côté serveur.**

1. **Côté client (UI)** : Utiliser `AuthGuard` avec `allowedRoles` pour protéger les pages
   - Exemple : `<AuthGuard allowedRoles={[USER_ROLES.ADMIN, USER_ROLES.COACH]}>`
   - Les vérifications client sont pour l'UX (masquer/afficher), pas pour la sécurité

2. **Côté serveur (API)** : TOUJOURS vérifier les rôles dans les routes API
   - Utiliser `hasAnyRole(role, [USER_ROLES.ADMIN, USER_ROLES.COACH])` après vérification du cookie de session
   - Retourner 403 si l'utilisateur n'a pas les droits
   - Ne JAMAIS faire confiance uniquement aux vérifications client

3. **Cohérence obligatoire** : Les rôles autorisés côté client DOIVENT correspondre exactement aux rôles vérifiés côté serveur
   - Si une page est accessible aux `[ADMIN, COACH]` via `AuthGuard`, la route API correspondante DOIT vérifier `[ADMIN, COACH]`
   - Si une route API est restreinte à `[ADMIN]` uniquement, la page UI DOIT utiliser `allowedRoles={[USER_ROLES.ADMIN]}`

4. **Vérification systématique** : Avant de créer/modifier une route API ou une page protégée :
   - Identifier les rôles nécessaires pour l'action
   - Vérifier que `AuthGuard` (si page) et la route API utilisent les MÊMES rôles
   - Documenter dans un commentaire les rôles autorisés si nécessaire

5. **Exemples de cohérence** :
   ```typescript
   // ✅ BON : Cohérence client/serveur
   // Page : <AuthGuard allowedRoles={[USER_ROLES.ADMIN]}>
   // API : if (!hasAnyRole(role, [USER_ROLES.ADMIN])) return 403;
   
   // ❌ MAUVAIS : Incohérence
   // Page : <AuthGuard allowedRoles={[USER_ROLES.ADMIN, USER_ROLES.COACH]}>
   // API : if (!hasAnyRole(role, [USER_ROLES.ADMIN])) return 403; // Manque COACH
   ```

6. **Routes admin** : Toutes les routes `/api/admin/*` sont réservées aux ADMIN uniquement
   - Ne JAMAIS autoriser COACH sur les routes admin
   - Utiliser `ADMIN_ONLY_ROLES = [USER_ROLES.ADMIN]` pour la clarté

7. **Routes coach/admin** : Les routes accessibles aux coachs ET admins doivent vérifier les deux rôles
   - Exemple : `/api/teams`, `/api/discord/channels` → `[USER_ROLES.ADMIN, USER_ROLES.COACH]`

## Patterns API - Helpers et Middlewares

### Helpers de réponse

- **TOUJOURS** utiliser les helpers depuis `@/lib/api/response-utils` :
  - `createSecureResponse(data, status)` - Réponse sécurisée avec headers Cache-Control
  - `createErrorResponse(message, status, details?)` - Réponse d'erreur standardisée
- **TOUJOURS** utiliser `handleApiError()` depuis `@/lib/api/error-handler` dans les blocs catch
- Exemple :
  ```typescript
  try {
    // ... logique ...
    return createSecureResponse({ success: true }, 200);
  } catch (error) {
    return handleApiError(error, {
      context: "app/api/example",
      defaultMessage: "Erreur lors de l'opération",
    });
  }
  ```

### Structure standard d'une route API

```typescript
import type { NextRequest } from "next/server";
import { requireAdminOrCoach } from "@/lib/api/auth-middleware";
import { createSecureResponse } from "@/lib/api/response-utils";
import { handleApiError, createErrorResponse } from "@/lib/api/error-handler";
import { validateEmail, validateId } from "@/lib/api/validation-helpers";
import { withRateLimit } from "@/lib/api/rate-limit-middleware";

export const runtime = "nodejs"; // Si nécessaire

export async function POST(req: NextRequest) {
  try {
    // 1. Authentification
    const auth = await requireAdminOrCoach(req, true);
    if (auth instanceof Response) return auth;

    // 2. Validation des paramètres
    const { email, teamId } = await req.json();
    const emailError = validateEmail(email);
    if (emailError) return emailError;
    
    const idError = validateId(teamId, "teamId");
    if (idError) return idError;

    // 3. Rate limiting (si nécessaire)
    const rateLimitError = withRateLimit({
      key: `action:${auth.uid}`,
      maxRequests: 10,
      windowMs: 60 * 1000,
    });
    if (rateLimitError) return rateLimitError;

    // 4. Logique métier
    // ...

    // 5. Réponse
    return createSecureResponse({ success: true }, 200);
  } catch (error) {
    return handleApiError(error, {
      context: "app/api/example",
      defaultMessage: "Erreur lors de l'opération",
    });
  }
}
```

### Documentation Swagger/OpenAPI

- **TOUJOURS** mettre à jour la documentation OpenAPI dans `src/lib/openapi.ts` lors de la création ou modification d'une route API
- **TOUJOURS** documenter :
  - Toutes les méthodes HTTP supportées (GET, POST, PATCH, DELETE, etc.)
  - Tous les paramètres (path, query, body) avec leurs types et contraintes
  - Tous les codes de réponse HTTP possibles (200, 400, 401, 403, 404, 429, 500)
  - Les schémas de réponse détaillés (structure JSON retournée)
  - Les contraintes de sécurité (`security: [{ SessionCookie: [] }]`)
  - Les tags appropriés (Auth, Admin, Discord, Equipes, Session, etc.)
- **Exceptions** (ne pas documenter) :
  - Routes internes : `/api/session/firebase-token` (utilisée uniquement par FirebaseAuthRestorer)
  - Routes méta : `/api/openapi` (route de documentation elle-même)
  - Routes webhook externes : `/api/discord/interactions`, `/api/discord/link-license` (optionnel, peuvent être documentées mais marquées comme webhooks)
  - Routes de monitoring : `/api/health` (optionnel)
- **Schémas réutilisables** : Créer des schémas dans `components.schemas` pour les types réutilisés (User, Location, DiscordChannel, etc.)
- **Vérification** : Après chaque modification de route API, vérifier que la documentation Swagger est à jour en consultant `/swagger` ou `/api/openapi`
- Exemple de documentation complète :
  ```typescript
  "/api/example/{id}": {
    get: {
      tags: ["Example"],
      summary: "Description courte",
      description: "Description détaillée de ce que fait la route.",
      security: [{ SessionCookie: [] }],
      parameters: [
        {
          name: "id",
          in: "path",
          required: true,
          description: "Identifiant de la ressource.",
          schema: { type: "string" },
        },
      ],
      responses: {
        "200": {
          description: "Succès.",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  success: { type: "boolean" },
                  data: { type: "object" },
                },
              },
            },
          },
        },
        "400": { description: "Paramètres invalides." },
        "403": { description: "Accès refusé." },
      },
    },
  },
  ```

## Performance

- Ne pas sur-optimiser prématurément, mais éviter les erreurs évidentes (boucles lourdes dans le rendu, re-renders inutiles).
- Utiliser les imports dynamiques Next.js (dynamic()) pour les composants lourds côté client si besoin.

## Accessibilité & UI

- Utiliser du HTML sémantique : <button> pour les actions, <a> pour les liens, <label> pour les champs de formulaire, etc.
- Fournir des 'alt' pertinents sur les images, et les attributs ARIA si nécessaire.
- Veiller à ce que les composants soient utilisables au clavier et lisibles par un lecteur d'écran.

## Tests & Robustesse

- Quand le projet contient déjà des tests, mettre à jour ou ajouter des tests unitaires / d'intégration pertinents (Jest/Vitest/RTL selon le repo).
- Ne jamais casser la suite de tests existante : adapter le code ou les tests de manière cohérente.

## Intégration dans le projet existant

- Respecter la configuration ESLint/Prettier du projet (ne pas introduire un autre formatage).
- Toujours vérifier que le code proposé pourra passer 'npm run lint' et 'npm run build'.
- Préserver la DX : messages d'erreurs clairs, pas de magie cachée, pas de changements non nécessaires.

## Quand tu écris ou modifies du code dans ce projet

- Appliquer toutes ces règles par défaut.
- Privilégier un code clair, maintenable et cohérent avec le reste du repo plutôt qu'une solution "clever".
- Si tu proposes une refactorisation, elle doit simplifier le projet (moins de duplication, meilleure séparation des responsabilités) sans casser le comportement existant.

# Workflow Git/GitHub - Branches et commits

## Structure des branches

- NE JAMAIS commiter directement sur `main` ou `master` pour du code de fonctionnalité
- TOUJOURS créer une branche dédiée avant de développer une fonctionnalité :
  - `feature/nom-fonctionnalite` pour les nouvelles fonctionnalités
  - `fix/nom-correction` pour les corrections de bugs
  - `refactor/nom-refactoring` pour les refactorings
  - `docs/nom-documentation` pour la documentation
- Si l'utilisateur demande de commiter/pousser sur main, lui rappeler de créer une branche et une PR d'abord

## Messages de commit (Conventional Commits)

- TOUJOURS utiliser le format Conventional Commits : `<type>(<scope>): <description>`
- Types autorisés : feat, fix, docs, style, refactor, test, chore
- Exemples :
  - `feat(discord): ajout de la vérification de signature Ed25519`
  - `fix(compositions): correction du calcul de brûlage`
  - `refactor(validation): simplification de la logique`
- Si l'utilisateur propose un message de commit non conforme, suggérer un message conforme

## Pull Requests obligatoires

- AVANT de pousser sur main, TOUJOURS créer une Pull Request
- Rappeler à l'utilisateur de :
  1. Pousser sa branche feature/fix/etc
  2. Créer une PR sur GitHub
  3. Attendre que les checks CI passent
  4. Obtenir une approbation si nécessaire
  5. Merge uniquement après validation
- Si l'utilisateur demande de push/merge direct sur main, refuser et rappeler le workflow PR

## Vérifications avant commit/push

- AVANT chaque commit, vérifier :
  - npm run check:dev passe (en développement)
  - Aucun TODO dans le code
  - Messages de commit conformes
  - **Documentation Swagger à jour** : Si une route API a été créée ou modifiée, vérifier que `src/lib/openapi.ts` est mis à jour
- AVANT chaque push, vérifier :
  - npm run check passe (lint + type-check + build)
  - On est sur une branche feature/fix/etc (pas main)
  - Le code est prêt pour review
  - **Documentation Swagger cohérente** : Toutes les routes API utilisées par le frontend sont documentées dans `src/lib/openapi.ts`

## Déploiement

- Rappeler que chaque merge sur main déclenche un déploiement automatique en production
- Ne jamais suggérer de push direct sur main pour du code de fonctionnalité
- Pour les hotfixes urgents, utiliser une branche `hotfix/nom-hotfix` avec PR accélérée
